;Pick-a-Number
;Revision of my 3rd Assembly program ever.
;Revision of my first original assembly program ever.
;Revised for TI-83 Plus

#define ProgStart $9D95
#include "ti83plus.inc"


theNumber EQU ProgStart + 200
rawInput EQU ProgStart + 210
numTries EQU ProgStart + 220
intInput EQU ProgStart + 221
gameOver EQU ProgStart + 222


.ORG ProgStart - 2			
    
	;some kind of strange headers without which I received warning:
	;83+/84+ prog does not begin with bytes BB6D or EF69
	;above warning was from SPASM assember & and program wouldn't run
	.db    t2ByteTok, tAsmCmp	
	
	LD A, $05				;prototype theNumber is hard-coded as 5
	LD (theNumber), A
	LD A, $05				;numTries will be 5. This code is only redundant due to init of theNumber which is not permanent
	LD (numTries), A
	LD A, $00
	LD (gameOver), A
	
	b_call(_ClrLCDFull)		;clear screen
	LD HL, messageStart
	CALL outputLine					

mainLoop:
	CALL getGuess
	CALL evalGuess
	
	;Check for gameover coming out of eval
	LD A, (gameOver)
	CP $01
	RET Z					;Return to OS
	
	;Evaluate tries remaining
	LD A, (numTries)
	DEC A					
	CP $0					;if A == 0
	JP Z, noMoreGuesses		;then show loss message 
	RET Z					;...and then exit to OS
	LD (numTries), A		;Otherwise, update numTries
	JP mainLoop				;Repeat

evalGuess:
	LD A, (intInput)
	LD B, A                 ;Indirectly load B with intInput
	LD A, (theNumber)
	CP B        			;If A == B flags => status (A-B)
	JP Z, correctGuess      ;A - B = 0
	JP NC, highGuess		;A - B = negative
	JP C, lowGuess			;A - B = positive
	
correctGuess: 			
	LD HL, messageWin
	CALL outputLine
	LD A, $01
	LD (gameOver), A
	RET

highGuess:
	LD HL, messageHigher
	CALL outputLine
	RET
	
lowGuess:	
	LD HL, messageLower
	CALL outputLine
	RET

noMoreGuesses:
	LD HL, messageLoss
	CALL outputLine
	RET
	
inputLine:
	B_CALL (_GetKey)		;OS-specific "input line" function
	LD (rawInput), A
	RET
	
outputLine:		
	B_CALL (_PutS)			;OS-specific "output line" function
	RET


getGuess:
    LD HL, messageGuess
	CALL outputLine		    ;Show "Try to guess my number"

    LD HL, rawInput
    LD A, $2                ;1 byte + 1 terminator char
    CALL inputLine
    
    ;try convert to int
    LD A, (rawInput)
    SUB $30                 ;Subtract 48 from ascii inputchar
    JP M, notADigit         ;S flag negative indicator => not a digit
    CP $0A                  ;compare to 10
    JP NC, notADigit        ;gte 10 => not a digit
    
    LD (intInput), A
    RET

notADigit:
    LD HL, messageNotADigit
    CALL outputLine
    JP getGuess

messageStart:
	.DB "I'm thinking of a number between 0 and 9.",0
	
messageGuess:	
	.DB "Try to guess my number.",0

messageLoss:
	.DB "No more guesses!",0

messageWin:
	.DB "You're a great guesser!",0
	
messageHigher:
	.DB "My number is higher.",0
	
messageLower:
	.DB "My number is lower.",0
	
messageNotADigit:
    .DB "You must enter a digit 0 to 9.",0