;Attempt at graphics on TI-83

.nolist
#include "ti83plus.inc"
#define ProgStart $9D95
.list

screenSize EQU 768


picData EQU appBackupScreen
rawInput EQU appBackupScreen + screenSize
x1 EQU rawInput + 1
y1 EQU rawInput + 2
ltpart EQU rawInput + 3
rtpart EQU rawInput + 4
offset EQU rawInput + 5

.ORG ProgStart - 2

.db t2ByteTok, tAsmCmp

clearGrBuffer:
	LD HL, PlotSScreen
	LD DE, PlotSScreen + 1
	LD BC, screenSize - 1
	LD (HL), 0
	LDIR
	
	;don't display blank screen yet, otherwise...B_CALL(_GrBufCpy)

main:
	;given a screen 96 px wide x 64 px tall
	;with 8px per byte, a row (horizontal line) is 12 bytes
	;draw a 1-byte horizontal line e.g. 1 of 8 lines for a sprite
	;Registers destroyed: A, HL, DE, BC
	
	;TO DO:
	;starting at y, loop 8 times incrementing pointer for y
	;also increment pointer for mysprite
	
	
	;first load the spriterow into memory
	;loop this for each sprite row
	LD A, (mySprite)
	LD (ltpart), A						;store a copy of sprite in leftpart
	LD (rtpart), A						;store a copy of sprite in rightpart
	
	;next let's find the byte row!
	;Address should be 12 * row + col
	;only need to do this once for first row
	LD A, 1								;row 1 (y)
	LD DE, $0C							;12d
	CALL de_times_a						;result is in HL
	PUSH HL								;save this result
	LD HL, PlotSScreen					;point to screen buffer
	POP BC								;retrieve result
	ADD HL, BC							;add result (row offset) to HL
	
	;now find byte column & bitshift (if any)
	;Byte offset should be col / 8
	;only need to do this once for first row
	LD A, 3								;col 3 (x)
	LD D, A								;dividend A
	LD E, 8								;divisor 8
	CALL div_d_e						;quotient (column) to D, remainder (bitshift) to A
	LD B, 0								;Zero-out the left half of BC
	LD C, D								;load quotient (column) to C of BC
	ADD HL, BC							;add (column) offset to HL
	CP 0								;compare A to zero
	JP Z, _leftByte						;if A is zero JP to leftByte, don't do any bit shifting

	;handle situation where x spans 2 bytes
	;A contains the offset
	;loop this for each sprite row
	LD B, A								;prepare to loop B times per offset bits
	LD C, A								;will use offset for masking momentarily
	PUSH HL								;preserve byte location
	CALL _shiftLoop						;loop will run B times to shift bits
	PUSH HL								;preserve rtpart
	LD HL, myMask						;NOTE: B is zero coming out of loop; C holds offset, so...
	ADD HL, BC							;...HL now points to correct mask for this offset
	LD A, (HL)							;stage the mask value in A
	LD B, A								;Load B with mask value
	POP HL								;retrieve rtpart loc
	LD A, (HL)							;Load A with rtpart value
	AND B								;apply mask
	LD (rtpart), A						;rtpart is now masked
	JP _rightByte
	
_shiftLoop:
	LD HL, ltpart
	SRL (HL)							;shift right
	LD HL, rtpart
	RR (HL)								;rotate right
	DJNZ _shiftLoop
	RET
	
_rightByte:
	POP HL								;retrieve byte location
	INC HL								;move one byte ahead for right byte
	LD A, (rtpart)
	LD (HL), A							;set byte value; e.g. rtpart
	DEC HL
	
_leftByte:
	LD A, (ltpart)
	LD (HL), A							;set byte value, e.g. ltpart
	B_CALL(_GrBufCpy)					;display the screen

pressAKeyToQuit:
	B_CALL(_GetKey)						;OS-specific "input line" function
	LD (rawInput), A
	RET


;fast multiplication route from http://tutorials.eeems.ca/ASMin28Days/lesson/day15.html
;HL = DE * A

de_times_a:
	LD HL, 0							;HL to store the product
	LD B, 8								;8-bits to check

_loop0:
	RRCA								;check LSB of A
	JR NC, _skip						;if zero, skip addition
	ADD HL, DE

_skip:
	SLA E								;shift DE one bit left
	RL D
	DJNZ _loop0
	RET

;division routine from wikiti.brandonw.net
;divide d by e, quotient result in d, remainder in a

div_d_e:
	XOR A
	LD B, 8

_loop1:
	SLA D
	RLA
	CP E
	JR C, $+4
	SUB E
	INC D

	DJNZ _loop1

	RET

mySprite:
.DB %00111100
.DB %01000010
.DB %10100101
.DB %10000001
.DB %10100101
.DB %10011001
.DB %01000010
.DB %00111100

myMask:
.DB 0, $80, $C0, $E0, $10, $F8, $FC, $FE, $FF

.END