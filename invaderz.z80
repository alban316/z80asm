;Space Invaders clone for TI-83
;Backlog:
; BUG: When col (px) spans bytes, sprite is being cutoff
; 2DO: Accept input, adjust pcol left or right
; 2DO: Accept input, spawn missile
; 2DO: Move entire fleet of invaders by adjusting vcol (on a timer)
; 2DO: Add animation of sprites, e.g. eyes legs
; 2DO: Allow missile animation incl adjust mrow (on a timer)
; 2DO: Allow drop bomb incl adjust brow (on a timer)
; 2DO: Sprite collision (missile vs invader, player vs invader, player vs bomb)
; 2DO: Count lives lost
; 2DO: Count invaders killed
; 2DO: Blank the invaders element where enemy was killed so nothing renders in that place (or add code to skip putSprite in such cases)
; 2DO: Have a 2nd copy of "invaders" array that points to left-facing sprites
; 2DO: In case of blanking an element, be sure to blank both left & right versions!

;Finished:
; 2DO: Display player sprite


.nolist
#include "ti83plus.inc"
#define ProgStart $9D95
.list

screenSize EQU 768


picData EQU appBackupScreen
rawInput EQU appBackupScreen + screenSize

;1-byte vars
col EQU rawInput + 1
row EQU rawInput + 2
ltpart EQU rawInput + 3
rtpart EQU rawInput + 4
spriteShift EQU rawInput + 5
currow EQU rawInput + 6
framect EQU rawInput + 7
loopct EQU rawInput + 8
curcol EQU rawInput + 9
curline EQU rawInput + 10
vcol EQU rawInput + 11
vrow EQU rawInput + 12
pcol EQU rawInput + 13
prow EQU rawInput + 14



.ORG ProgStart - 2

.db t2ByteTok, tAsmCmp

	;given a screen 96 px wide x 64 px tall
	;(in 8x8 terms this is 12 x 8)
	;with 8px per byte, a row (horizontal line) is 12 bytes
	;valid range for sprite upper left (col, row) is (0,0) to (88 px,57 px) or ($58, $38)

	CALL clearGrBuffer
	
	;init player row, col
	LD A, $38
	LD (prow), A
	
	LD A, $2C
	LD (pcol), A

	;init invader (fleet) left column
	LD A, 3
	LD (vcol), A
	
	;init invader (fleet) top row
	LD A, 0
	LD (vrow), A
	
	LD A, 4								;HARD CODED FLEET LINES = 4
	LD (curline), A
	LD HL, invaders
	LD A, (vrow)
	LD (row), A
	CALL putInvaders
	
	CALL putPlayer
	
	B_CALL(_GrBufCpy)					;finally display the screen buffer!
	RET

putPlayer:
	LD IX, player						;loads right-facing version
	LD A, (prow)
	LD (row), A
	LD A, (pcol)
	LD (col), A
	CALL putSprite
	RET

putInvaders:
	;(row),(vcol) must be initialized
	;(row) will be destroyed--so keep a copy of it
	;(col) will be destroyed--so keep a copy of it
	
	;for 1st iteration HL = invaders
	;subsequent iterations stepped through during invaderLine
	LD A, $0B							;HARD CODED NUMBER OF COLS = 11d
	LD (curcol), A
	LD A, (vcol)						;recall invader fleet vcol value
	LD (col), A							;init col at vcol value

	CALL invaderLine
	
	;are we done yet?
	LD A, (curline)						;stage curline in A
	DEC A								;decrement by 1
	RET Z								;quit if done

	;not done, queue up the next row
	LD (curline), A						;upd curline for next loop
	LD A, (row)							;stage row in A
	ADD A, 8							;increment by 8px
	LD (row), A							;update row in memory
	
	JP putInvaders

invaderLine:
	;(row),(col) must be initialized
	;HL must point to invaders array e.g. LD HL, invaders
	;(col) will be destroyed--so keep a copy of it
	
	;HL is already pointing at correct element of invaders
	LD B, 0								;init BC upper byte to 0
	LD A, (HL)							;element value is spritesheet offset in bytes
	LD C, A								;init BC lower byte to staged value

	LD IX, sp_sheet						;get spritesheet
	ADD IX, BC							;value at index is sprite frame offset in bytes
	PUSH HL								;save our place in invaders array
	CALL putSprite

	;check if we're done with this line
	;either way, we still need to POP & INC to be ready for next col or next line
	POP HL								;recall our place in invaders array
	INC HL								;advance to next element
	LD A, (curcol)						;stage curcol (index) in A
	DEC A								;decrement by 1
	RET Z								;quit if we're done

	;not done
	LD (curcol), A						;update curcol for next loop
	LD A, (col)							;recall col in px
	ADD A, 8							;add 8px
	LD (col), A							;update col

	JP invaderLine

;anim:
	;(framect) must be initialized
	;IX must be pre-loaded with sprite, e.g. LD IX, pacman
	;this works cuz putSprite INCs IX thru each sprite row
	;so last row of frame sets up 1st row of next frame
	;CALL clearGrBuffer					;erase entire buffer every time?? only if we must
	
	;CALL putSprite
	;LD A, (framect)
	;DEC A
	;RET Z
	;LD (framect), A
	;JR anim

putSprite:
	;(row),(col) must be initialized
	;IX must be pre-loaded with sprite, e.g. LD IX, pacman
	;draws an 8x8 sprite
	;looks up row, col values from variables
	;IX must contain pointer to sprite
	;Registers destroyed: A, HL, DE, BC, IX

	;first let's find the byte row!
	;Address should be 12 * row + col
	;only need to do this once for 1st row (we'll just increment thereafter)
	LD A, (row)							;row in px
	LD DE, $0C							;12d
	CALL de_times_a						;result is in HL
	PUSH HL								;save this result
	LD HL, PlotSScreen					;point to screen buffer
	POP BC								;retrieve result
	ADD HL, BC							;add result (row offset) to HL
	
	;next find byte column & bitshift (if any)
	;Byte offset should be col / 8
	;only need to do this once for 1st row (we'll just increment thereafter)
	LD A, (col)							;col in px
	LD D, A								;dividend A
	LD E, 8								;divisor 8
	CALL div_d_e						;quotient (column) to D, remainder (bitshift) to A
	LD (spriteShift), A					;save bitshift to RAM
	LD B, 0								;Zero-out the left half of BC
	LD C, D								;load quotient (column) to C of BC
	ADD HL, BC							;add (column) offset to HL
	
	;init sprite currow at zero
	;expect IX to contain ptr to sprite
	LD A, 0
	LD (currow), A

_spriteRow:
	;draw a 1-byte horizontal row of a sprite
	;first load the spriterow into memory
	LD A, (IX)							;load sprite from IX to A
	LD (ltpart), A						;store a copy of sprite in leftpart
	LD (rtpart), A						;store a copy of sprite in rightpart
	LD A, (spriteShift)					;recall spriteshift
	CP 0								;compare A to zero
	JP Z, _leftByte						;if A is zero JP to leftByte, don't do any bit shifting

	;handle situation where x spans 2 bytes
	;A contains the shift offset from above
	LD B, A								;prepare to loop B times per offset bits
	LD C, A								;will use offset for masking momentarily
	PUSH HL								;preserve byte location
	CALL _shiftLoop						;loop will run B times to shift bits
	PUSH HL								;preserve rtpart
	LD HL, myMask						;NOTE: B is zero coming out of loop; C holds offset, so...
	ADD HL, BC							;...HL now points to correct mask for this offset
	LD A, (HL)							;stage the mask value in A
	LD B, A								;Load B with mask value
	POP HL								;retrieve rtpart loc
	LD A, (HL)							;Load A with rtpart value
	AND B								;apply mask
	LD (rtpart), A						;rtpart is now masked
	JP _rightByte
	
_shiftLoop:
	LD HL, ltpart
	SRL (HL)							;shift right
	LD HL, rtpart
	RR (HL)								;rotate right
	DJNZ _shiftLoop
	RET
	
_rightByte:
	POP HL								;retrieve byte location
	INC HL								;move one byte ahead for right byte
	LD A, (rtpart)						;Stage A with right half of sprite bits
	OR (HL)								;OR with whatever's already there
	LD (HL), A							;set byte value; i.e. rtpart 
	DEC HL								;drop back to original SScreen location 
	
_leftByte:
	;for no bitshift, HL already contains correct SScreen loc, no need to pop
	LD A, (ltpart)						;Stage A with left half of sprite bits
	OR (HL)								;OR with whatever's already there
	LD (HL), A							;set byte value, e.g. ltpart
	LD B, 0								;B of BC to 0
	LD C, $0C							;C of BC to 12d
	ADD HL, BC							;increment HL by 12 for next row
	INC IX								;increment ptr to spriteRow

	LD A, (currow)
	INC A								;increment sprite row counter
	LD (currow), A
	CP 8								;stop after 8 iterations
	JP NZ, _spriteRow
	
	;used to display sprite here
	;now moved to outermost loop after all sprites buffered

	RET

pressAKeyToQuit:
	;this is not currently being called 
	;and doesn't seem to be needed! Cuz screen is not automatically exiting like it did before
	B_CALL(_GetKey)						;OS-specific "input line" function
	LD (rawInput), A
	RET

clearGrBuffer:
	LD HL, PlotSScreen
	LD DE, PlotSScreen + 1
	LD BC, screenSize - 1
	LD (HL), 0
	LDIR
	RET

;fast multiplication route from http://tutorials.eeems.ca/ASMin28Days/lesson/day15.html
;HL = DE * A

de_times_a:
	LD HL, 0							;HL to store the product
	LD B, 8								;8-bits to check

_loop0:
	RRCA								;check LSB of A
	JR NC, _skip						;if zero, skip addition
	ADD HL, DE

_skip:
	SLA E								;shift DE one bit left
	RL D
	DJNZ _loop0
	RET

;division routine from wikiti.brandonw.net
;divide d by e, quotient result in d, remainder in a

div_d_e:
	XOR A
	LD B, 8

_loop1:
	SLA D
	RLA
	CP E
	JR C, $+4
	SUB E
	INC D

	DJNZ _loop1

	RET

sp_sheet:
;style 0, right facing
.DB %00000000
.DB %01100011
.DB %00010100
.DB %00111110
.DB %01101011
.DB %01111111
.DB %01000001
.DB %00110110

;style 0, left facing
.DB %00000000
.DB %11000110
.DB %00101000
.DB %01111100
.DB %11010110
.DB %11111110
.DB %10000010
.DB %01101100

;style 1, right facing
.DB %00000000
.DB %00011100
.DB %00111110
.DB %01111111
.DB %01011101
.DB %01111111
.DB %00101010
.DB %01001001

;style 1, left facing
.DB %00000000
.DB %00111000
.DB %01111100
.DB %11111110
.DB %10111010
.DB %11111110
.DB %01010100
.DB %10010010

invaders:
;offset by index = 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0 
;.DB 0, $10, 0, $10, 0, $10, 0, $10, 0, $10, 0
;.DB $10, 0, $10, 0, $10, 0, $10, 0, $10, 0, $10
.DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
.DB $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10
.DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
.DB $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10

player:
;right facing
.DB %00000000
.DB %00000000
.DB %00000000
.DB %00010100
.DB %00011100
.DB %00111110
.DB %01111111
.DB %01111111

;left facing
.DB %00000000
.DB %00101000
.DB %00111000
.DB %01111100
.DB %11111110
.DB %11111110
.DB %11111110
.DB %11111110

myMask:
.DB 0, $80, $C0, $E0, $F0, $F8, $FC, $FE, $FF

.END